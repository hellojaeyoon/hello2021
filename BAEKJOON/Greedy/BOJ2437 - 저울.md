# BOJ2437 - 저울

https://www.acmicpc.net/problem/2437

---

​	한 번에 수십개의 저울추를 두고 만들 수 없는 최솟값을 생각하면 머리가 아프다. 그냥 이미 우리는 저울추들이 주어져있고, 이 저울추들을 이용해서 1부터 모든 저울추들의 합(K)까지 다 만들 수 있다고 하자. 이 때 K+1이 만들 수 없는 수의 최솟값이다.

- 1하나가 있을때 위의 상황이 성립한다. 물론 1이 없다면 이 문제의 정답은 1이다.

- 자 그럼 문제에서 저울추들이 주어졌을때, 이것을 오름차순정렬을 하면

  - 1, 2, ... 이러한 형태로 나올것이다(물론2가 아닐수도 있다)

  - 이제 무게가 1인 저울추 하나가 있을때로부터 새로운 저울추를 하나씩 추가해주는 작업이라고 생각하자

- 다시 원래의 상황으로 돌아가서 1부터 모든 저울추들의 합까지 다 만들 수 있는 이 상황에서 새로운 무게의 저울추 M을 추가한다고 생각하자

- M의 크기는 K+1보다 큰 경우

  - K+1을 만들기 위해서 M은 사용하지 못할것이고, 앞의 저울추들의 합이 K이기 때문에 K+1은 만들 수 없는 수가 된다. 최솟값은 유지가 된다
  - 계속 더 큰 무게의 저울추를 추가하는 작업을 하면서 문제에서 주어진 저울추들을 다 추가하는 과정인데, K+1은 영영 만들 수 없는 숫자가 되기 때문에, 정답은 K+1이된다

- M의 크기가 K+1 이하인 경우

  - 1 부터 K까지의 숫자를 모두 만들 수 있었기 때문에

    M, M+1, M+2, ... M + K 까지 모두 만들 수 있는 숫자가 된다

  - 즉  1부터 M+K까지의 모든 숫자를 만들 수 있고 (여기서 M+K는 새로운 저울추를 포함한 모든 저울추들의 합), M+K+1이 만들 수 없는 무게의 최솟값이 된다

---

```python
N = int(input())
weights = list(map(int, input().split()))
weights.sort()

if weights[0] != 1:
    print(1)
else:
    minW = 2
    check = True
    for i in range(1, N):
        if weights[i] > minW:
            print(minW)
            check = False
            break
        else:
            minW += weights[i]
    if check:
        print(minW)
```